CPUs combine an ALU, control unit, memory, and clock to perform tasks based on instructions. What makes CPU’s powerful is that they are programmable, such that if you write a different set of instructions, it will perform a completely different task. This way, the CPU becomes a hardware that can be used by easy to modify software. 

Instructions are stored in memory, allowing for easy program modification and control by software. From the point of view of the CPU, machine code is stored in RAM, but is typically also kept in a set of caches for performance reasons. There may be different caches for instructions and data, depending on the architecture. 

Instructions are sequences of opcodes and addresses/registers that control CPU operations. Each opcode responds to a particular instruction within the computer’s defined instruction table and performs the given task utilizing the address or registers in the second half of the instruction sequence. Most instructions have one or more opcode fields that specify the basic instruction type (such as arithmetic, logical, jump, etc.), the operation (such as add or compare), and other fields that may give the type of the operand(s), the addressing mode(s), the addressing offset(s) or index, or the operand value itself (such constant operands contained in an instruction are called immediate). Every processor or processor family has its own instruction set. Instructions are patterns of bits, digits, or characters that correspond to machine commands. Thus, the instruction set is specific to a class of processors using (mostly) the same architecture. 

Some examples of some basic instructions within the instruction table include LOAD, STORE, ADD, and SUBTRACT, enabling simple arithmetic operations. We also have other operations such as JUMP and JUMP_NEGATIVE instructions that allow for program flow control and conditional execution. JUMP allows for the processor to update the instruction address register to a new address, possibly skipping some instructions while JUMP_NEGATIVE does the same thing in the event that an ALU instruction outputs a negative result. There is also the HALT instruction which signifies the end of a program and prevents infinite loops.

It should be noted that we can store instructions and data in the same memory, as there is no difference fundamentally as they are all binary numbers. It is for this reason that the HALT instruction is important as to differentiate the instructions from the data. You should also keep in mind that the placement of JUMP or JUMP_NEGATIVE operations should be carefully considered, as it is possible to create a sequence of instructions such that we have an infinite loop. To break such a loop, we need another condition jump to exit the looped sequence in order to proceed with the program.

In these examples, we are working with a simple CPU that uses 8-bit instructions. This leads to complications as we are limited to 16 lines of instruction and data. Modern CPUs use larger instruction lengths (32-64 bits) and variable-length instructions, increasing instruction capacity and flexibility. How the patterns are organized varies with the particular architecture and type of instruction. 
