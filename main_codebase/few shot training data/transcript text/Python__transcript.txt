Expression is a combination of objects and operators that computes a value. Many expressions involve what is known as the boolean data type. Objects of the boolean type have only two values. These are called True and False. In Python, you need to capitalize these words, True and False, for Python to understand them as boolean type. Let&#39;s just check very quickly. If we type True, Python tells us this is a boolean object. Or if we ask Python, what is the type of False, with F capitalized, Python tells us this is a boolean object. Note that if I don&#39;t capitalize false, Python doesn&#39;t know what this object is. It doesn&#39;t understand that. So you need to be sure to capitalize your boolean types. Operations involving logic, so-called boolean operations, take in one or more boolean object and then they return one boolean object back to you. There are only three boolean operations, which are &quot;or&quot;, &quot;and&quot;, and &quot;not&quot;. So let&#39;s try these out. Let&#39;s start with &quot;or&quot;. &quot;Or&quot; between x and y is going to be True if either x is True or y is True, or both are True. So for example, if we say True or False, then Python returns True. True or True would also be True. So the only time &quot;or&quot; would be False-- if both the first and second object surrounding &quot;or&quot; are False. &quot;And&quot; is only true if both objects are True. So if we type True and True, the answer is going to be True. However, if we turned the second True to False, &quot;and&quot; is going to be False. So in order for &quot;and&quot; to be True, both of the objects need to be True. Finally, we have the &quot;not&quot; operation, which simply negates the value of the object. So if we say not True, Python gives us False. And if we say not False, Python returns to us True. We often need to compare objects in our programs. There are a total of eight different comparison operations in Python. Although these are commonly used for numeric types, we can actually apply them to other types as well. For example, if you&#39;re comparing two sequences, the comparison is carried out element-wise. So you&#39;re comparing the first element of your first sequence to your first element in your second sequence, and so on. The result of a comparison like this is always a boolean type, either True or False. It&#39;s perhaps easiest to understand these comparisons through a simple example that involves numbers. So let&#39;s try out a couple of them. Let&#39;s say you are comparing two numbers. We might ask Python, is 2 less than 4? Python returns True to us. We can also ask, is 2 less than or equal to, say, 2? And in this case, the answer is again True. We can test for equality by using two equal signs. 2 is equal to 2, so Python returns True to us. And finally we can ask, are two objects not equal to one another, by using the exclamation mark or exclamation point. In this case, the answer is False, because two is equal to 2. These two comparisons are used to test whether two objects are the one and the same. Notice that this is different than asking if the contents of two objects are the same. So let&#39;s see what this implies using a little bit of code. We could ask Python if the list that contains numbers 2 and 3 is the same as the list containing numbers 3 and 3. The answer is, of course, False in this case. If we modify the second list, now both lists have the numbers 2 and 3 in them. The answer is going to be True. The lists are identical in content. However, if we wanted to ask if the first list is the same object as the second list, we would use the &quot;is&quot; comparison. And Python tells us that this is False. If we&#39;d like to know if the first list is not the same object as the second list, we can use the &quot;is not&quot; operation. And in this case, Python returns True. So we actually have two lists here. They happen to have the same contents, but we do have two objects. That&#39;s why this comparison returns False. How would we test equality of two numbers that are a floating point number and an integer? So we can see how testing if 2.0 is equal to 2.0 returns True. But what happens if we ask Python, is 2.0 equal to 2? In this case 2.0 is a floating point number, whereas 2 is an integer. What happens in this situation is the following: Python takes the second number, which is number 2, an integer-- it turns that into a floating point number. The floating point representation of the integer 2 is 2.0. So now we are comparing implicitly 2.0 to 2.0. Therefore the answer is going to be True.